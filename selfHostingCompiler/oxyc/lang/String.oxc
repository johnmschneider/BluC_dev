#include <string.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include "Throwable.oxc"

class String
{
    char* cString;
    int len;
    Throwable t;
    
    this(char* value)
    {

        this->len = 0;
        
        char c = value[0];
        for (int i = 0; ; i++)
        {
            c = value[i];
            
            if (c != '\0')
            {
                this->len ++;
            }
            else
            {
                break;
            }
        }
        
        //add 1 since c strings are null-terminated (needing an extra character)
        this->cString = (char*) malloc(sizeof(char) * (this->length() + 1));
        strcpy(this->cString, value);
    }
    
    ~this()
    {
        free(this->cString);
    }
    
    char* getCString()
    {
        return this->cString;
    }
    
    Throwable charAt(int index)
    {
        if (index > this->length())
        {
            fprintf(stderr, "[String.charAt]: index %i greater than length\n",
                index);
            
            //return null terminator
            char* returnee = this->cString + (this->length() + 1);
            
            this->t(returnee, "IndexOutOfBounds");
        }
        else
        {
            char* returnee = this->cString + index;
            
            this->t(returnee, Throwable_noError);
        }
        
        return this->t;
    }
    
    int length()
    {
        return this->len;
    }
    
    bool isEmpty()
    {
        return this->length() == 0;
    }

    void append(char* appendThis)
    {
        int appendeeLen = 0;

        char c = appendThis[0];
        for (int i = 0; ; i++)
        {
            c = appendThis[i];
            
            if (c != '\0')
            {
                appendeeLen ++;
            }
            else
            {
                break;
            }
        }

        //add 1 to string to account for null terminator
        int newLen = this->length() + appendeeLen + 1;

        //don't include null terminator in length
        this->len = newLen - 1;
        char* oldVal = this->cString;
        this->cString = malloc(sizeof(char) * newLen);
        strcpy(this->cString, oldVal);
        free(oldVal);
        strcat(this->cString, appendThis);
    }
    
    bool equals(char* rawStr)
    {
        bool isEqual = true;
        int len = this->length();
        
        if (len == 0 && rawStr[0] == '\0')
        {
            //empty string compared to empty string
            isEqual = true;
        }
        else
        {
            for (int i = 0; i < len; i++)
            {
                if (rawStr[i] == '\0')
                {
                    isEqual = false;
                    break;
                }
                else if (i == len - 1 && rawStr[i + 1] != '\0')
                {
                    isEqual = false;
                    break;
                }
                else if (this->cString[i] != rawStr[i])
                {
                    isEqual = false;
                    break;
                }
            }
        }
        
        return isEqual;
    }
    
    bool stringEquals(String* other)
    {
        return this->equals(other->getCString());
    }
    
    int indexOf(char* charPattern)
    {
        int returnee = -1;
        String* strPattern = malloc(sizeof(String));
        int patternLen;

        strPattern(charPattern);
        patternLen = strPattern->length();

        if (patternLen != 0)
        {
            bool isMatchingSoFar = false;
            int curIndexInPattern = -1;
            int matchStartIndex = -1;
            int patternLastIndex = patternLen - 1;
            int thisLen = this->length();
            int thisLastIndex = thisLen - 1;

            for (int i = 0; i < thisLen; i++)
            {
                if (isMatchingSoFar)
                {
                    if (this->cString[i] == charPattern[curIndexInPattern])
                    {
                        if (curIndexInPattern == patternLastIndex)
                        {
                            returnee = matchStartIndex;
                            break;
                        }
                        else if (i != thisLastIndex)
                        {
                            isMatchingSoFar = true;
                            curIndexInPattern ++;
                        }
                        else
                        {
                            isMatchingSoFar = false;
                        }
                    }
                    else
                    {
                        isMatchingSoFar = false;
                        curIndexInPattern = -1;
                        matchStartIndex = -1;
                    }
                }
                else
                {
                    if (this->cString[i] == charPattern[0])
                    {
                        if (patternLen == 1)
                        {
                            returnee = i;
                            break;
                        }
                        else
                        {
                            isMatchingSoFar = true;

                            //1 because we already matched the 0'th index
                            curIndexInPattern = 1;
                            matchStartIndex = i;
                        }
                    }
                } // end else
            } // end for
        } // end if (strPattern->length() != 0)

        free(strPattern);
        return returnee;
    }

    int stringIndexOf(String other)
    {
        return this->indexOf(other->getCString());
    }

    char* split(char* pattern)
    {

    }
};
