<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FunctionHandler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;BluC&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">bluC.parser.handlers.statement</a> &gt; <span class="el_source">FunctionHandler.java</span></div><h1>FunctionHandler.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2021 John Schneider.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package bluC.parser.handlers.statement;

import bluC.Logger;
import bluC.BluC;
import bluC.transpiler.Scope;
import bluC.transpiler.Statement;
import bluC.transpiler.Token;
import bluC.parser.Parser;
import bluC.transpiler.Statement.VarDeclaration;
import bluC.transpiler.TokenFileInfo;
import bluC.transpiler.TokenInfo;

/**
 *
 * @author John Schneider
 */
public class FunctionHandler
{
    public static final String METHOD_NAMESPACE_PREFIX = &quot;methods&quot;;
    
    private final Parser parser;
    private final StatementHandler statementHandler;
    private final BlockHandler blockHandler;
    private final VariableHandler varHandler;
<span class="fc" id="L41">    private static long unresolvedFunctionNamesCount = Long.MIN_VALUE;</span>
    
    public FunctionHandler(Parser parser, StatementHandler statementHandler,
        BlockHandler blockHandler)
<span class="fc" id="L45">    {</span>
<span class="fc" id="L46">        this.parser = parser;</span>
<span class="fc" id="L47">        this.statementHandler = statementHandler;</span>
<span class="fc" id="L48">        this.blockHandler = blockHandler;</span>
<span class="fc" id="L49">        varHandler = statementHandler.getVarHandler();</span>
<span class="fc" id="L50">    }</span>
    
    public Statement handleFunctionOrMethod(VarDeclaration.Sign returnSign, 
        VarDeclaration.SimplifiedType returnSimplifiedType)
    {
<span class="nc bnc" id="L55" title="All 2 branches missed.">        if (parser.isInAClass())</span>
        {
<span class="nc" id="L57">            return handleMethod(returnSign, returnSimplifiedType);</span>
        }

<span class="nc" id="L60">        return handleFunction(returnSign, returnSimplifiedType);</span>
    }
    
    private Statement handleFunction(VarDeclaration.Sign returnSign, 
        VarDeclaration.SimplifiedType returnSimplifiedType)
    {
<span class="nc" id="L66">        Statement.Function function = getFuncOrMethod(returnSign, </span>
            returnSimplifiedType);
        
<span class="nc" id="L69">        parser.pushScope(new Scope(parser.getCurrentScope(), function));</span>
<span class="nc" id="L70">        handleGlobalFunctionDeclaration(function);</span>
<span class="nc" id="L71">        parser.popScope(parser.getCurToken());</span>

<span class="nc" id="L73">        return function;</span>
    }
    
    private Statement.Function getFuncOrMethod(VarDeclaration.Sign returnSign, 
        VarDeclaration.SimplifiedType returnSimplifiedType) 
    {
<span class="nc" id="L79">        int returnPointerLevel = varHandler.getPointerLevel();</span>
        Statement.VarDeclaration returnType;
        Statement.Function function;
        Token functionName;

<span class="nc" id="L84">        parser.nextToken();</span>

<span class="nc" id="L86">        functionName = parser.getCurToken();</span>
<span class="nc" id="L87">        returnType = getReturnTypeVar(returnSign, returnSimplifiedType, </span>
            returnPointerLevel);
<span class="nc" id="L89">        function = new Statement.Function(returnType, functionName,</span>
<span class="nc" id="L90">            functionName.getLineIndex());</span>
        
<span class="nc" id="L92">        return function;</span>
    }
    
    private Statement.VarDeclaration getReturnTypeVar(
        VarDeclaration.Sign returnTypeSign, 
        VarDeclaration.SimplifiedType returnTypeType, 
        int returnTypePointerLevel)
    {
<span class="nc" id="L100">        Token curToken = parser.getCurToken();</span>
<span class="nc" id="L101">        Token varName = new Token(</span>
            new TokenInfo(VarDeclaration.RETURN_VAR_NAME, false),
                
<span class="nc" id="L104">            new TokenFileInfo(curToken.getFilepath(), </span>
<span class="nc" id="L105">                curToken.getLineIndex()));</span>

<span class="nc" id="L107">        return new Statement.VarDeclaration(returnTypeSign, returnTypeType, </span>
            returnTypePointerLevel, varName, null, null,
<span class="nc" id="L109">            curToken.getLineIndex());</span>
    }
    
    public Statement handleMethod(VarDeclaration.Sign returnSign, 
        VarDeclaration.SimplifiedType returnSimplifiedType)
    {
<span class="nc" id="L115">        Statement.Function rawMethod = </span>
<span class="nc" id="L116">            getFuncOrMethod(returnSign, returnSimplifiedType);</span>
        
<span class="nc" id="L118">        Statement.ClassDef curClass = (Statement.ClassDef) (parser.</span>
<span class="nc" id="L119">            getCurrentScope().getScopeType());</span>
        
<span class="nc" id="L121">        Statement.Method method = new Statement.Method(curClass, </span>
<span class="nc" id="L122">            rawMethod.getReturnType(), rawMethod.getNameToken(), </span>
<span class="nc" id="L123">            getMangledMethodName(curClass, rawMethod),</span>
<span class="nc" id="L124">            parser, rawMethod.getStartingLineIndex());</span>

<span class="nc" id="L126">        parser.pushScope(new Scope(parser.getCurrentScope(), method));</span>
<span class="nc" id="L127">        handleMethodDeclaration(method);</span>
<span class="nc" id="L128">        parser.popScope(parser.getCurToken());</span>

<span class="nc" id="L130">        return method;</span>
    }
    
    private String getMangledMethodName(Statement.ClassDef curClass,
        Statement.Function rawMethod)
    {
<span class="nc" id="L136">        return BluC.BLU_C_NAMESPACE_PREFIX + &quot;_&quot; + ClassHandler.</span>
<span class="nc" id="L137">            CLASS_NAMESPACE_PREFIX + &quot;_&quot; + curClass.getClassName().</span>
<span class="nc" id="L138">            getTextContent() + &quot;_&quot; + METHOD_NAMESPACE_PREFIX + &quot;_&quot; +</span>
<span class="nc" id="L139">            rawMethod.getNameText();</span>
        //TODO : add package support in mangling
    }
    
    private Statement handleMethodDeclaration(Statement.Method method)
    {
<span class="nc" id="L145">        handleGlobalFunctionDeclaration(method);</span>
        
<span class="nc" id="L147">        return method;</span>
    }
    
    private void handleGlobalFunctionDeclaration(
        Statement.Function function)
    {
<span class="nc bnc" id="L153" title="All 2 branches missed.">        if (function.hasValidName())</span>
        {
<span class="nc" id="L155">            handleGlobalFunctionDeclarationWithValidReturnTypeAndName(</span>
                function);
        }
        else
        {
<span class="nc" id="L160">            handleBadGlobalFunctionName(function);</span>
        }
<span class="nc" id="L162">    }</span>
    
    /**
     * This is when we are either: (1) on a valid function name, or (2) the
     *  parser was able to synchronize a bad function name and we are carrying
     *  on to report any additional errors (and are thus technically on a valid
     *  function name).
     */
    private void handleGlobalFunctionDeclarationWithValidReturnTypeAndName(
        Statement.Function functionWithRetTypeAndName)
    {
        Statement.ParameterList params;
        Token next;
<span class="nc" id="L175">        Token functionName = functionWithRetTypeAndName.getNameToken();</span>
        
<span class="nc" id="L177">        params = getFunctionParameters(functionName);</span>
<span class="nc" id="L178">        functionWithRetTypeAndName.setParameters(params);</span>
<span class="nc" id="L179">        next = parser.peek();</span>
        
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (next.getTextContent().equals(&quot;{&quot;))</span>
        {
<span class="nc" id="L183">            parser.nextToken();</span>
<span class="nc" id="L184">            blockHandler.addStatementsToBlock(next, functionWithRetTypeAndName);</span>
            
            /** 
             * It seems we can't do this because the parser, by design, must
             *  automatically move on to the next token after the current 
             *  statement was processed. If that step is omitted in the parser
             *  then we end up with an infinite parse loop.
             * 
             * I left the code here to remind myself not to try and modify the
             *  parse tree in this way in the future.
             * 
             * As such, statement processors are now required to end on the last
             *  token of the statement, so that the parser's automatic call to
             *  nextToken will not miss any tokens. For instance, a function
             *  handler will end with parser's current token set to the closing
             *  curly brace.
             */
            //parser.nextToken(); // move to token after &quot;}&quot;
        }
        else
        {
<span class="nc" id="L205">            Logger.err(next, &quot;Expected \&quot;{\&quot; to open body of function \&quot;&quot; +</span>
<span class="nc" id="L206">                functionName.getTextContent() + &quot;\&quot;&quot;);</span>
        }
<span class="nc" id="L208">    }</span>
    
    private Statement.ParameterList getFunctionParameters(Token functionName)
    {
<span class="nc" id="L212">        Token expectedOpenParen = parser.peek();</span>
        
<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (expectedOpenParen.getTextContent().equals(&quot;(&quot;))</span>
        {
            //move parser to &quot;(&quot; token
<span class="nc" id="L217">            parser.nextToken();</span>
            
<span class="nc" id="L219">            Statement.ParameterList returnee = new Statement.ParameterList(</span>
<span class="nc" id="L220">                parser.peek().getLineIndex());</span>
            
<span class="nc" id="L222">            addParametersToParameterList(returnee, functionName);</span>
            
<span class="nc" id="L224">            return returnee;</span>
        }
        else
        {
<span class="nc" id="L228">            Logger.err(expectedOpenParen, &quot;Expected \&quot;(\&quot; to start parameter &quot; +</span>
<span class="nc" id="L229">                &quot;list for function \&quot;&quot; + functionName.getTextContent() + &quot;\&quot;&quot;);</span>
<span class="nc" id="L230">            return new Statement.ParameterList(parser.peek(2).getLineIndex());</span>
        }
    }
    
    private void addParametersToParameterList(Statement.ParameterList params,
        Token functionName)
    {
<span class="nc" id="L237">        boolean closingParenFound   = false;</span>
        Token curToken;
        
        /**
         * We should now be on the &quot;(&quot; token. 
         * 
         * VariableHandler.handleVarDeclarationOrHigher() requires the parser to
         *  be on the token immediately BEFORE the variable declaration starts.
         */
<span class="nc" id="L246">        curToken = parser.getCurToken();</span>
        
<span class="nc bnc" id="L248" title="All 2 branches missed.">        while (!parser.atEOF())</span>
        {
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (curToken.getTextContent().equals(&quot;)&quot;))</span>
            {
<span class="nc" id="L252">                closingParenFound = true;</span>
<span class="nc" id="L253">                break;</span>
            }
            
<span class="nc" id="L256">            params.addParameter((Statement.VarDeclaration) </span>
<span class="nc" id="L257">                varHandler.handleVarDeclarationOrHigher());</span>
            
<span class="nc" id="L259">            parser.nextToken();</span>
<span class="nc" id="L260">            curToken = parser.getCurToken();</span>
        }
        
<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (!closingParenFound)</span>
        {
<span class="nc" id="L265">            Logger.err(curToken, &quot;Expected \&quot;)\&quot; to end parameter list for &quot; +</span>
<span class="nc" id="L266">                &quot;function \&quot;&quot; + functionName.getTextContent() + &quot;\&quot;&quot;);</span>
        }
<span class="nc" id="L268">    }</span>
    
    private void handleBadGlobalFunctionName(
        Statement.Function function)
    {
<span class="nc" id="L273">        Token funcName = function.getNameToken();</span>
        
<span class="nc" id="L275">        Logger.err(funcName,&quot;Expected function name to follow \&quot;&quot; + </span>
<span class="nc" id="L276">            parser.peek(-1).getTextContent() + &quot;\&quot; (token \&quot;&quot; + </span>
<span class="nc" id="L277">            funcName.getTextContent() + &quot;\&quot; is an invalid name)&quot;);</span>

        //  synchronize parser
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (funcName.getTextContent().equals(&quot;;&quot;))</span>
        {
            //name missing
<span class="nc" id="L283">            parser.prevToken();</span>
        }
        else
        {
            //invalid name
<span class="nc" id="L288">            parser.gotoEndOfStatement();</span>
        }
        
<span class="nc" id="L291">        Token autoGeneratedName = getAutoGeneratedName(funcName);</span>
        
        //add token so that 
        //  handleGlobalFunctionDeclarationWithValidReturnTypeAndName will see 
        //  the auto generated name
<span class="nc" id="L296">        parser.addToken(autoGeneratedName, parser.getCurTokIndex() + 1);</span>
<span class="nc" id="L297">        function.setName(autoGeneratedName);</span>
        
<span class="nc" id="L299">        handleGlobalFunctionDeclarationWithValidReturnTypeAndName(</span>
            function);
<span class="nc" id="L301">    }</span>
    
    private Token getAutoGeneratedName(Token funcName)
    {
<span class="nc" id="L305">        Token returnee = new Token(</span>
            new TokenInfo(&quot;unresolvedFunctionName&quot; +
<span class="nc" id="L307">                Long.toUnsignedString(unresolvedFunctionNamesCount), true), </span>
                
<span class="nc" id="L309">            new TokenFileInfo(funcName.getFilepath(), funcName.getLineIndex()));</span>
        
<span class="nc" id="L311">        unresolvedFunctionNamesCount++;</span>
        
<span class="nc" id="L313">        return returnee;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>