<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>VariableHandler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;BluC&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">bluC.parser.handlers.statement</a> &gt; <span class="el_source">VariableHandler.java</span></div><h1>VariableHandler.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2021 John Schneider.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package bluC.parser.handlers.statement;

import java.util.ArrayList;
import bluC.Logger;
import bluC.transpiler.Scope;
import bluC.transpiler.Statement;
import bluC.transpiler.Token;
import bluC.parser.Parser;
import bluC.parser.exceptions.InvalidSizeModifier;
import bluC.transpiler.Statement.VarDeclaration;
import bluC.transpiler.Statement.VarDeclaration.SimplifiedType;
import bluC.transpiler.TokenFileInfo;
import bluC.transpiler.TokenInfo;
import bluC.parser.handlers.expression.ExpressionHandler;

/**
 *
 * @author John Schneider
 */
public class VariableHandler
{
    private final Parser            parser;
    private final StatementHandler  statementHandler;
    private FunctionHandler         funcHandler;
    private ExpressionHandler       expressionHandler;
<span class="fc" id="L42">    private static long             unresolvedVariableNamesCount = </span>
        Long.MIN_VALUE;
    
    public class TypeAndClassID
    {
        private final SimplifiedType type;
        private final long classID;
        
        public TypeAndClassID(SimplifiedType type, long classID)
<span class="fc" id="L51">        {</span>
<span class="fc" id="L52">            this.type = type;</span>
<span class="fc" id="L53">            this.classID = classID;</span>
<span class="fc" id="L54">        }</span>
        
        public SimplifiedType getType()
        {
<span class="fc" id="L58">            return type;</span>
        }
        
        public long getClassID()
        {
<span class="fc" id="L63">            return classID;</span>
        }
    }
    
    public VariableHandler(Parser parser, StatementHandler statementHandler)
<span class="fc" id="L68">    {</span>
<span class="fc" id="L69">        this.parser = parser;</span>
<span class="fc" id="L70">        this.statementHandler = statementHandler;</span>
<span class="fc" id="L71">    }</span>
            
    
    public void initHandlers()
    {
<span class="fc" id="L76">        funcHandler = statementHandler.getFuncHandler();</span>
<span class="fc" id="L77">        expressionHandler = statementHandler.getExpressionHandler();</span>
<span class="fc" id="L78">    }</span>
    
    /**
     * Handles a variable declaration or higher.
     * 
     * Expects the parser to be on the token immediately BEFORE a potential
     *  variable declaration.
     */
    public Statement handleVarDeclarationOrHigher()
    {
<span class="fc" id="L88">        Token   startToken          = parser.getCurToken();</span>
<span class="fc" id="L89">        int     startTokenIndex     = parser.getCurTokIndex();</span>
        VarDeclaration.Sign
<span class="fc" id="L91">                sign                = getSign();</span>
        TypeAndClassID 
<span class="fc" id="L93">                typeAndClassID      = getTypeAndClassID();</span>
        
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">        if (typeAndClassID != null)</span>
        {
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">            if (parser.peekMatches(2, &quot;(&quot;))</span>
            {
<span class="nc" id="L99">                return funcHandler.handleFunctionOrMethod(sign,</span>
<span class="nc" id="L100">                    typeAndClassID.getType());</span>
            }
            else
            {
<span class="fc" id="L104">                return handleVarDeclarationWithValidType(sign, </span>
<span class="fc" id="L105">                    typeAndClassID.getType(), typeAndClassID.getClassID());</span>
            }
        }
        
<span class="nc" id="L109">        parser.setToken(startTokenIndex);</span>
<span class="nc" id="L110">        return statementHandler.handleBlockStatementOrHigher();</span>
    }
    
    /**
     * This function expects the parser's currentToken to be on the variable
     *  name.
     * 
     * If the original program is erroneous and there is no such token,
     *  this function outputs a compile-level error (issue with compilation,
     *  not the compiler itself) and synchronizes the parser by returning an
     *  automatically generated valid variable name.
     * 
     * Since the compiler is flagged as having a fatal compile error, this
     *  program will not compile.
     */
    private Statement handleVarDeclarationWithValidType(
        VarDeclaration.Sign sign, VarDeclaration.SimplifiedType type, 
        long classID)
    {
        Token   varName;
<span class="fc" id="L130">        int     pointerLevel = getPointerLevel();</span>
        
        // curToken *must* now be the variable's name or it is a syntax error
<span class="fc" id="L133">        parser.nextToken();</span>
<span class="fc" id="L134">        varName = parser.getCurToken();</span>

<span class="fc" id="L136">        Token   nextToken       = parser.peek();</span>
<span class="fc" id="L137">        String  nextTokenText   = nextToken.getTextContent();</span>

<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        if (varName.isValidName())</span>
        {
<span class="fc" id="L141">            return handleVarDeclarationWithValidTypeAndName(sign, type, </span>
                pointerLevel, varName, nextTokenText, classID);
        }
        else
        {
<span class="nc" id="L146">            return handleBadVarName(sign, type, pointerLevel, varName);</span>
        }
    }
    
    /**
     * Returns the current pointerLevel of the variable/function return type.
     * 
     * Ends with the parser's curToken set to one of two things:
     *  1) the last asterisk of the pointer (if it exists)
     *  2) the token the parser was on before this function call (if there is no
     *      pointer level).
     */
    public int getPointerLevel()
    {
<span class="fc" id="L160">        int pointerLevel = 0;</span>
        
<span class="fc" id="L162">        String peekText = parser.peek().getTextContent();</span>
        
<span class="pc bpc" id="L164" title="2 of 4 branches missed.">        while(!parser.atEOF() &amp;&amp; peekText.equals(&quot;*&quot;))</span>
        {
<span class="nc" id="L166">            pointerLevel++;</span>
<span class="nc" id="L167">            parser.nextToken();</span>
<span class="nc" id="L168">            peekText = parser.peek().getTextContent();</span>
        }
        
<span class="fc" id="L171">        return pointerLevel;</span>
    }
    
    private Statement handleVarDeclarationWithValidTypeAndName(
        VarDeclaration.Sign sign, VarDeclaration.SimplifiedType type, 
        int pointerLevel, Token varName, String nextTokenText, long classID)
    {
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        if (nextTokenText.equals(&quot;=&quot;))</span>
        {
<span class="fc" id="L180">            return handleVarDeclarationWithAssignment(sign, type, pointerLevel,</span>
                varName, classID);
        }
<span class="nc bnc" id="L183" title="All 4 branches missed.">        else if (nextTokenText.equals(&quot;;&quot;) || nextTokenText.equals(&quot;,&quot;) ||</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">            nextTokenText.equals(&quot;)&quot;))</span>
        {
<span class="nc" id="L186">            return handleVarDeclarationWithoutAssignment(sign, type, </span>
                pointerLevel, varName, classID);
        }
        else
        {
<span class="nc" id="L191">            Token curToken = parser.getCurToken();</span>
            
<span class="nc" id="L193">            Logger.err(curToken, &quot;Expected assignment operator or semicolon &quot; +</span>
                &quot;after variable declaration&quot;);

<span class="nc" id="L196">            parser.gotoEndOfStatement();</span>

<span class="nc" id="L198">            return handleVarDeclarationWithoutAssignment(sign, type, </span>
                pointerLevel, varName, classID);
        }
    }
    
    private Statement handleBadVarName(VarDeclaration.Sign sign, 
        VarDeclaration.SimplifiedType type,
        int pointerLevel, Token varName)
    {
<span class="nc" id="L207">        Logger.err(varName, &quot;Expected variable name to follow \&quot;&quot; + </span>
<span class="nc" id="L208">            type.name().toLowerCase().replace(&quot;_&quot;, &quot; &quot;) + &quot;\&quot; (token \&quot;&quot; + </span>
<span class="nc" id="L209">            varName.getTextContent() + &quot;\&quot; is an invalid name)&quot;);</span>

        //  synchronize parser
<span class="nc bnc" id="L212" title="All 2 branches missed.">        if (varName.getTextContent().equals(&quot;;&quot;))</span>
        {
            //name missing
<span class="nc" id="L215">            parser.prevToken();</span>
        }
        else
        {
            //invalid name
<span class="nc" id="L220">            parser.gotoEndOfStatement();</span>
        }
        
<span class="nc" id="L223">        Token autoGeneratedName = getAutoGeneratedName(varName);</span>
<span class="nc" id="L224">        Statement returnee =  new VarDeclaration(sign, type, </span>
            pointerLevel, autoGeneratedName,
<span class="nc" id="L226">            null, null, autoGeneratedName.getLineIndex());</span>
<span class="nc" id="L227">        return returnee;</span>
    }
    
    private Token getAutoGeneratedName(Token varName)
    {
<span class="nc" id="L232">        Token returnee = new Token(</span>
            new TokenInfo(&quot;unresolvedVariableName&quot; + 
<span class="nc" id="L234">                Long.toUnsignedString(unresolvedVariableNamesCount), true),</span>
                
<span class="nc" id="L236">            new TokenFileInfo(varName.getFilepath(), varName.getLineIndex()));</span>
        
<span class="nc" id="L238">        unresolvedVariableNamesCount++;</span>
        
<span class="nc" id="L240">        return returnee;</span>
    }
    
    /**
     * Handles a syntactically valid &quot;variable declaration with assignment&quot;
     *  statement.
     * 
     * On failure, it returns a VarDaclaration as-if it were successful, but
     *  flags and reports a compile error. This VarDeclaration is simply to
     *  synchronize the parser from the error.
     * 
     * The returned VarDeclaration is *not* added to the current scope's
     *  variable list -- the previous variable definition is used when parsing
     *  further.
     */        
    private Statement handleVarDeclarationWithAssignment(
        VarDeclaration.Sign sign, VarDeclaration.SimplifiedType type, 
        int pointerLevel, Token varName, long classID)
    {
        VarDeclaration  var;
        boolean         alreadyDeclared;
<span class="fc" id="L261">        long            startLineIndex = parser.getCurTokLineIndex();</span>
        
        // set curToken equal to &quot;=&quot;
<span class="fc" id="L264">        parser.nextToken();</span>
        
<span class="fc" id="L266">        var = new VarDeclaration(sign, type, pointerLevel, varName, </span>
<span class="fc" id="L267">            parser.getCurToken(), expressionHandler.handleExpression(),</span>
            startLineIndex);
<span class="fc" id="L269">        alreadyDeclared = isVarAlreadyDeclaredInThisScope(var);</span>
        
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">        if (alreadyDeclared)</span>
        {
<span class="nc" id="L273">            Logger.err(varName, &quot;Variable \&quot;&quot; + varName.getTextContent() + </span>
                &quot;\&quot; already declared&quot;);
        }
        else
        {
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">            if (type == SimplifiedType.CLASS)</span>
            {
<span class="nc" id="L280">                var.setClassID(classID);</span>
            }
            
<span class="fc" id="L283">            parser.getCurrentScope().addVariableToScope(var);</span>
        }
        
<span class="fc" id="L286">        return var;</span>
    }
    
    private Statement handleVarDeclarationWithoutAssignment(
        VarDeclaration.Sign sign, VarDeclaration.SimplifiedType type, 
        int pointerLevel, Token varName, long classID)
    {
<span class="nc" id="L293">        VarDeclaration var = new VarDeclaration(sign, type, </span>
<span class="nc" id="L294">            pointerLevel, varName, null, null, varName.getLineIndex());</span>
<span class="nc" id="L295">        boolean alreadyDeclared = isVarAlreadyDeclaredInThisScope(var);</span>

<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (alreadyDeclared)</span>
        {
<span class="nc" id="L299">            Logger.err(varName, &quot;Variable \&quot;&quot; + varName.getTextContent() + </span>
                &quot;\&quot; already declared in this scope&quot;);
        }
        else
        {
<span class="nc bnc" id="L304" title="All 2 branches missed.">            if (type == SimplifiedType.CLASS)</span>
            {
<span class="nc" id="L306">                var.setClassID(classID);</span>
            }
            
<span class="nc" id="L309">            parser.getCurrentScope().addVariableToScope(var);</span>
        }

<span class="nc" id="L312">        return var;</span>
    }
    
    public boolean isVarNameTheSame(VarDeclaration var, Token potentialVarName)
    {
<span class="nc" id="L317">        return var.getNameText().equals(potentialVarName.getTextContent());</span>
    }
    
    private VarDeclaration getVarAlreadyDeclaredInThisScope(Scope scope, 
        Token var)
    {
<span class="fc" id="L323">        ArrayList&lt;VarDeclaration&gt; variablesInThisScope = </span>
<span class="fc" id="L324">            scope.getVariablesInThisScope();</span>
        
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">        for (VarDeclaration var2 : variablesInThisScope)</span>
        {
<span class="nc bnc" id="L328" title="All 2 branches missed.">            if (isVarNameTheSame(var2, var))</span>
            {
<span class="nc" id="L330">                return var2;</span>
            }
<span class="nc" id="L332">        }</span>

<span class="fc" id="L334">        return null;</span>
    }
    
    public VarDeclaration getVarAlreadyDeclaredInThisScope(Token var)
    {
<span class="fc" id="L339">        return getVarAlreadyDeclaredInThisScope(parser.getCurrentScope(), var);</span>
    }
    
    public VarDeclaration getVarAlreadyDeclaredInThisScope(
        VarDeclaration var)
    {
<span class="fc" id="L345">        return getVarAlreadyDeclaredInThisScope(var.getName());</span>
    }
    
    public VarDeclaration getVarAlreadyDeclaredInThisScopeOrHigher(
        Token potentialVarName)
    {
<span class="nc" id="L351">        Scope curSearchScope = parser.getCurrentScope();</span>
        
<span class="nc bnc" id="L353" title="All 2 branches missed.">        while (curSearchScope != null)</span>
        {
<span class="nc" id="L355">            VarDeclaration variable = getVarAlreadyDeclaredInThisScope</span>
<span class="nc" id="L356">                (curSearchScope, potentialVarName);</span>
            
<span class="nc bnc" id="L358" title="All 2 branches missed.">            if (variable != null)</span>
            {
<span class="nc" id="L360">                return variable;</span>
            }
            
<span class="nc" id="L363">            curSearchScope = curSearchScope.getParent();</span>
<span class="nc" id="L364">        }</span>
        
<span class="nc" id="L366">        return null;</span>
    }
    
    public boolean isVarAlreadyDeclaredInThisScope(VarDeclaration var)
    {
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">        return getVarAlreadyDeclaredInThisScope(var) != null;</span>
    }
    
    /**
     * Parses the current signed/unsigned specifier of the variable (if it
     *  exists). 
     * 
     * Ends the function with the current token being set to the signed/unsigned
     *  specifier (if it exists), or the token the function started on if
     *  there is no such specifier present.
     */
    private VarDeclaration.Sign getSign()
    {
<span class="fc" id="L384">        String              peekText    = parser.peek().getTextContent();</span>
<span class="fc" id="L385">        VarDeclaration.Sign sign        = VarDeclaration.Sign.UNSPECIFIED;</span>
        
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        if (peekText.equals(&quot;signed&quot;))</span>
        {
<span class="nc" id="L389">            sign = VarDeclaration.Sign.SIGNED;</span>
            
            //consume the peek
<span class="nc" id="L392">            parser.nextToken();</span>
        }
<span class="fc bfc" id="L394" title="All 2 branches covered.">        else if (peekText.equals(&quot;unsigned&quot;))</span>
        {
<span class="fc" id="L396">            sign = VarDeclaration.Sign.UNSIGNED;</span>
            
            //consume the peek
<span class="fc" id="L399">            parser.nextToken();</span>
        }
        
<span class="fc" id="L402">        return sign;</span>
    }
    
    /**
     * Parses and returns the size modifier for a variable. Always leaves the
     *  parser on the last token of the size modifier, even if it is two or
     *  more words long.
     */
    private VarDeclaration.SizeModifier getSizeModifier() 
        throws InvalidSizeModifier
    {
<span class="fc" id="L413">        Token sizeMod1 = parser.peek();</span>
<span class="fc" id="L414">        Token sizeMod2OrTypeOrName = parser.peek(2);</span>
        
<span class="fc" id="L416">        String sizeMod1Text = sizeMod1.getTextContent();</span>
<span class="fc" id="L417">        String sizeMod2OrTypeOrNameText = sizeMod2OrTypeOrName.getTextContent();</span>
        
<span class="fc" id="L419">        VarDeclaration.SizeModifier sizeModifier = VarDeclaration.SizeModifier.</span>
            UNSPECIFIED;
        
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">        if (sizeMod1Text.equals(&quot;short&quot;))</span>
        {
//            if (sizeMod2OrTypeOrNameText.equals(&quot;char&quot;)  || 
//                sizeMod2OrTypeOrNameText.equals(&quot;short&quot;) ||
//                sizeMod2OrTypeOrNameText.equals(&quot;long&quot;)  ||
//                sizeMod2OrTypeOrNameText.equals(&quot;float&quot;) ||
//                sizeMod2OrTypeOrNameText.equals(&quot;double&quot;))
//            {
//                sizeErrorOccurred = true;
//            }
//            else
//            {
//                parser.nextToken();
//                sizeModifier = VarDeclaration.SizeModifier.SHORT;
//            }
            
            // move parser from current token to &quot;short&quot; keyword
<span class="nc" id="L439">            parser.nextToken();</span>
            
<span class="nc bnc" id="L441" title="All 2 branches missed.">            if (sizeMod2OrTypeOrNameText.equals(&quot;int&quot;))</span>
            {
<span class="nc" id="L443">                sizeModifier = VarDeclaration.SizeModifier.SHORT;</span>
            }
            else
            {
                // this is most likely (but not *definitely*) either an invalid
                //  data type base for this modifier (ex. short dounle) or a
                //  variable name that they forgot to specify the base,
                //  either way synchronize the parser
<span class="nc" id="L451">                throw new InvalidSizeModifier(sizeMod1, sizeMod2OrTypeOrName);</span>
            }
        }
<span class="fc bfc" id="L454" title="All 2 branches covered.">        else if (sizeMod1Text.equals(&quot;long&quot;))</span>
        {
<span class="fc bfc" id="L456" title="All 2 branches covered.">            if (sizeMod2OrTypeOrNameText.equals(&quot;long&quot;))</span>
            {
<span class="fc" id="L458">                Token typeOrName = parser.peek(3);</span>
<span class="fc" id="L459">                String typeOrNameText = </span>
<span class="fc" id="L460">                    typeOrName.getTextContent();</span>
                
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">                if (typeOrNameText.equals(&quot;char&quot;)  || </span>
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">                      typeOrNameText.equals(&quot;short&quot;) || </span>
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">                      typeOrNameText.equals(&quot;long&quot;)  ||</span>
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">                      typeOrNameText.equals(&quot;float&quot;) ||</span>
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">                      typeOrNameText.equals(&quot;double&quot;))</span>
                {
                    //  synchronize parser
<span class="nc" id="L469">                    parser.nextToken();</span>
<span class="nc" id="L470">                    parser.nextToken();</span>
                    
<span class="nc" id="L472">                    throw new InvalidSizeModifier(sizeMod1, </span>
                        sizeMod2OrTypeOrName, typeOrName);
                }
                else
                {
<span class="fc" id="L477">                    sizeModifier = VarDeclaration.SizeModifier.LONG_LONG;</span>
                
                    //  align tokens such that nextToken() is the variable type
<span class="fc" id="L480">                    parser.nextToken();</span>
                    
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">                    if (typeOrNameText.equals(&quot;int&quot;))</span>
                    {
<span class="nc" id="L484">                        parser.nextToken();</span>
                    }
                }
<span class="fc" id="L487">            }</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">            else if (sizeMod2OrTypeOrNameText.equals(&quot;char&quot;) ||</span>
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">                    sizeMod2OrTypeOrNameText.equals(&quot;short&quot;) ||</span>
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">                    sizeMod2OrTypeOrNameText.equals(&quot;float&quot;))</span>
            {
<span class="nc" id="L492">                parser.nextToken();</span>
<span class="nc" id="L493">                throw new InvalidSizeModifier(sizeMod1, </span>
                    sizeMod2OrTypeOrName);
            }
            else
            {
<span class="fc" id="L498">                parser.nextToken();</span>
<span class="fc" id="L499">                sizeModifier = VarDeclaration.SizeModifier.LONG;</span>
            }
        }
        
<span class="fc" id="L503">        return sizeModifier;</span>
    }
    
    private TypeAndClassID getTypeAndClassID()
    {
        VarDeclaration.SizeModifier sizeModifier;
        
        try
        {
<span class="fc" id="L512">            sizeModifier = getSizeModifier();</span>
        } 
<span class="nc" id="L514">        catch (InvalidSizeModifier ex)</span>
        {
<span class="nc" id="L516">            Token errAt = ex.getSizeMod1();</span>
<span class="nc" id="L517">            Logger.err(errAt, ex.getMessage());</span>
            
            //synchronize parser
<span class="nc" id="L520">            sizeModifier = VarDeclaration.SizeModifier.UNSPECIFIED;</span>
<span class="fc" id="L521">        }</span>
        
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">        if (sizeModifier == VarDeclaration.SizeModifier.SHORT)</span>
        {
<span class="nc bnc" id="L525" title="All 2 branches missed.">            if (parser.peekMatches(&quot;int&quot;))</span>
            {
                //consume size modifier token
<span class="nc" id="L528">                parser.nextToken();</span>
            }
            else
            {
<span class="nc" id="L532">                return guessTypeFromSizeErrorAndLogError(sizeModifier);</span>
            }
            
<span class="nc" id="L535">            return new TypeAndClassID(VarDeclaration.SimplifiedType.SHORT,</span>
                ClassHandler.CLASS_UNSPECIFIED);
        }
<span class="fc bfc" id="L538" title="All 2 branches covered.">        else if (sizeModifier == VarDeclaration.SizeModifier.LONG)</span>
        {
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">            if (parser.peekMatches(&quot;double&quot;))</span>
            {
                //consume size modifier token
<span class="nc" id="L543">                parser.nextToken();</span>
                
<span class="nc" id="L545">                return new TypeAndClassID(VarDeclaration.SimplifiedType.</span>
                   LONG_DOUBLE, ClassHandler.CLASS_UNSPECIFIED);
            }
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">            else if (parser.peekMatches(&quot;int&quot;))</span>
            {
                //consume size modifier token
<span class="fc" id="L551">                parser.nextToken();</span>
            }
            else 
            {
<span class="nc" id="L555">                return guessTypeFromSizeErrorAndLogError(sizeModifier);</span>
            }
            
<span class="fc" id="L558">            return new TypeAndClassID(VarDeclaration.SimplifiedType.LONG,</span>
                ClassHandler.CLASS_UNSPECIFIED);
        }
<span class="fc bfc" id="L561" title="All 2 branches covered.">        else if (sizeModifier == VarDeclaration.SizeModifier.LONG_LONG)</span>
        {
            //align tokens such that nextToken is variable type or varName
<span class="fc" id="L564">            parser.nextToken();</span>
            
<span class="fc" id="L566">            Token   varTypeOrName       = parser.peek();</span>
<span class="fc" id="L567">            String  varTypeOrNameText   = varTypeOrName.getTextContent();</span>
            
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">            if (varTypeOrNameText.equals(&quot;int&quot;))</span>
            {
                //consume var type token
<span class="nc" id="L572">                parser.nextToken();</span>
            }
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">            else if (!varTypeOrName.isValidName())</span>
            {
<span class="nc" id="L576">                return guessTypeFromSizeErrorAndLogError(sizeModifier);</span>
            }
            
<span class="fc" id="L579">            return new TypeAndClassID(VarDeclaration.SimplifiedType.LONG_LONG,</span>
                ClassHandler.CLASS_UNSPECIFIED);
        }
        else
        {
<span class="fc" id="L584">            return getUnmodifiedType();</span>
        }
    }
    
    /**
     * Parses a variable type without regards to the modifier used.
     */
    private TypeAndClassID getUnmodifiedType() {
<span class="fc" id="L592">        parser.nextToken();</span>
<span class="fc" id="L593">        String type = parser.getCurTokText();</span>

<span class="pc bpc" id="L595" title="1 of 2 branches missed.">        if (type.equals(&quot;char&quot;))</span>
        {
<span class="fc" id="L597">            return new TypeAndClassID(VarDeclaration.SimplifiedType.CHAR,</span>
                ClassHandler.CLASS_UNSPECIFIED);
        }
<span class="nc bnc" id="L600" title="All 2 branches missed.">        else if (type.equals(&quot;int&quot;))</span>
        {
<span class="nc" id="L602">            return new TypeAndClassID(VarDeclaration.SimplifiedType.INT,</span>
                ClassHandler.CLASS_UNSPECIFIED);
        }
<span class="nc bnc" id="L605" title="All 2 branches missed.">        else if (type.equals(&quot;float&quot;))</span>
        {
<span class="nc" id="L607">            return new TypeAndClassID(VarDeclaration.SimplifiedType.FLOAT,</span>
                ClassHandler.CLASS_UNSPECIFIED);
        }
<span class="nc bnc" id="L610" title="All 2 branches missed.">        else if (type.equals(&quot;double&quot;))</span>
        {
<span class="nc" id="L612">            return new TypeAndClassID(VarDeclaration.SimplifiedType.DOUBLE,</span>
                ClassHandler.CLASS_UNSPECIFIED);
        }
<span class="nc bnc" id="L615" title="All 2 branches missed.">        else if (type.equals(&quot;void&quot;)) </span>
        {
<span class="nc" id="L617">            return new TypeAndClassID(VarDeclaration.SimplifiedType.VOID,</span>
                ClassHandler.CLASS_UNSPECIFIED);
        }
<span class="nc bnc" id="L620" title="All 2 branches missed.">        else if (ClassHandler.isClassDefined(parser.getCurToken()))</span>
        {
<span class="nc" id="L622">            return new TypeAndClassID(VarDeclaration.SimplifiedType.CLASS,</span>
<span class="nc" id="L623">                ClassHandler.getClassID(parser.getCurToken()));</span>
        }

        //TODO : else check for structs

        //error! unrecognized symbol that we *think* is a variable but it
        //  has no type!
        //
        //attempt to synchronize parser
<span class="nc" id="L632">        return null;</span>
    }
    
    private TypeAndClassID guessTypeFromSizeErrorAndLogError(
        VarDeclaration.SizeModifier sizeModifier)
    {
<span class="nc" id="L638">        Logger.err(parser.getCurToken(), &quot;invalid size specifier \&quot;&quot; + </span>
<span class="nc" id="L639">            sizeModifier.getActualModifierText() + &quot;\&quot; for type \&quot;&quot; +</span>
<span class="nc" id="L640">            parser.peek().getTextContent() + &quot;\&quot;&quot;);</span>
<span class="nc" id="L641">        return getUnmodifiedType();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>