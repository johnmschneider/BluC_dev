<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StatementHandler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;BluC&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">bluC.parser.handlers.statement</a> &gt; <span class="el_source">StatementHandler.java</span></div><h1>StatementHandler.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2021 John Schneider.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package bluC.parser.handlers.statement;

import bluC.parser.handlers.expression.ExpressionHandler;
import bluC.Logger;
import bluC.transpiler.Expression;
import bluC.transpiler.Statement;
import bluC.transpiler.Statement.VarDeclaration.Sign;
import bluC.transpiler.Statement.VarDeclaration.SimplifiedType;
import bluC.transpiler.Token;
import bluC.transpiler.TokenFileInfo;
import bluC.transpiler.TokenInfo;
import bluC.parser.Parser;

/**
 *
 * @author John Schneider
 */
public class StatementHandler
{
    private final Parser            parser;
    private final ExpressionHandler expressionHandler;
    private final VariableHandler   varHandler;
    private final FunctionHandler   funcHandler;
    private final BlockHandler      blockHandler;
    private final IfHandler         ifHandler;
    private final ClassHandler      classHandler;
    
    public StatementHandler(Parser parser)
<span class="fc" id="L45">    {</span>
<span class="fc" id="L46">        this.parser = parser;</span>
        
<span class="fc" id="L48">        varHandler          = new VariableHandler(parser, this);</span>
<span class="fc" id="L49">        expressionHandler   = new ExpressionHandler(parser, this);</span>
<span class="fc" id="L50">        blockHandler        = new BlockHandler(parser, this);</span>
<span class="fc" id="L51">        funcHandler         = new FunctionHandler(parser, this, blockHandler);</span>
<span class="fc" id="L52">        ifHandler           = new IfHandler(parser, blockHandler, </span>
            expressionHandler);
<span class="fc" id="L54">        classHandler        = new ClassHandler(parser, varHandler, blockHandler,</span>
            funcHandler);
        
        //due to circular references to varHandler we had to create a 
        //  reference to varHandler and THEN retrieve references to the other 
        //  handlers
<span class="fc" id="L60">        varHandler.initHandlers();</span>
<span class="fc" id="L61">    }</span>
    
    
    public FunctionHandler getFuncHandler()
    {
<span class="fc" id="L66">        return funcHandler;</span>
    }
    
    public ExpressionHandler getExpressionHandler()
    {
<span class="fc" id="L71">        return expressionHandler;</span>
    }
    
    public VariableHandler getVarHandler()
    {
<span class="fc" id="L76">        return varHandler;</span>
    }
    
    public Statement handleStatement(boolean checkForSemicolon)
    {
<span class="fc" id="L81">        Statement returnee = varHandler.handleVarDeclarationOrHigher();</span>
        
<span class="pc bpc" id="L83" title="2 of 4 branches missed.">        if (checkForSemicolon &amp;&amp;</span>
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">            !(returnee instanceof Statement.Block) &amp;&amp; !parser.peekMatches(&quot;;&quot;))</span>
        {
<span class="nc" id="L86">            Token curToken = parser.getCurToken();</span>
<span class="nc" id="L87">            Logger.err(curToken, &quot;Expected \&quot;;\&quot; to end statement&quot;);</span>
        }
        
<span class="fc" id="L90">        parser.nextToken();</span>
<span class="fc" id="L91">        return returnee;</span>
    }
    
    public Statement handleBlockStatementOrHigher()
    {
<span class="nc" id="L96">        Token openBrace = parser.peek();</span>
        
<span class="nc bnc" id="L98" title="All 2 branches missed.">        if (openBrace.getTextContent().equals(&quot;{&quot;))</span>
        {
<span class="nc" id="L100">            Statement.Block block = blockHandler.handleBlock(openBrace);</span>
<span class="nc" id="L101">            return block;</span>
        }
        else 
        {
<span class="nc" id="L105">            return handleIfStatementOrHigher();</span>
        }
    }
    
    private Statement handleIfStatementOrHigher()
    {
<span class="nc" id="L111">        Token potentialIf = parser.peek();</span>
        
<span class="nc bnc" id="L113" title="All 2 branches missed.">        if (potentialIf.getTextContent().equals(&quot;if&quot;))</span>
        {
<span class="nc" id="L115">            return ifHandler.handleIfStatement(potentialIf);</span>
        }
        else
        {
<span class="nc" id="L119">            return handleExpressionStatementOrHigher();</span>
        }
    }
    
    private Statement handleExpressionStatementOrHigher()
    {
<span class="nc" id="L125">        Token next = parser.peek();</span>
        
        //&quot;this&quot; can be used in an expression (class member access) [or 
        //  constructor declaration, but in this case it's to parse the &quot;this&quot; 
        //  expression]
<span class="nc bnc" id="L130" title="All 4 branches missed.">        if (!next.isReservedWord() || next.getTextContent().equals(&quot;this&quot;)) </span>
        {
<span class="nc" id="L132">            Expression expression = expressionHandler.handleExpression();</span>

<span class="nc" id="L134">            return new Statement.ExpressionStatement(expression, </span>
<span class="nc" id="L135">                next.getLineIndex());</span>
        }
        else
        {
<span class="nc" id="L139">            return handleClassDefinitionOrHigher();</span>
        }
    }
    
    private Statement handleClassDefinitionOrHigher() 
    {
<span class="nc" id="L145">        Token next = parser.peek();</span>
        
<span class="nc bnc" id="L147" title="All 2 branches missed.">        if (next.getTextContent().equals(&quot;class&quot;))</span>
        {
<span class="nc" id="L149">            return classHandler.handleClass(parser.peek());</span>
        }
        else 
        {
<span class="nc" id="L153">            return handleReturnOrHigher();</span>
        }
    }
    
    private Statement handleReturnOrHigher()
    {
<span class="nc" id="L159">        Token next = parser.peek();</span>
        
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (next.getTextContent().equals(&quot;return&quot;))</span>
        {
            Statement returnedExpression;
            Statement.Return return_;
            
<span class="nc" id="L166">            parser.nextToken();</span>
<span class="nc" id="L167">            returnedExpression = handleExpressionStatementOrHigher();</span>
            
<span class="nc" id="L169">            return_ = new Statement.Return(returnedExpression,</span>
<span class="nc" id="L170">                parser.getCurTokLineIndex());</span>
            
<span class="nc" id="L172">            return return_;</span>
        }
        else
        {
<span class="nc" id="L176">            return handlePackage();</span>
        }
    }
    
    private Statement handlePackage()
    {
<span class="nc" id="L182">        Token next = parser.peek();</span>
        
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (next.getTextContent().equals(&quot;package&quot;))</span>
        {
<span class="nc" id="L186">            return getPackage();</span>
        }
        else
        {
<span class="nc" id="L190">            return handleInvalidStartOfStatement();</span>
        }
    }
    
    private Statement getPackage()
    {
<span class="nc" id="L196">        int     startTokenIndex = parser.getCurTokIndex();</span>
<span class="nc" id="L197">        Token   packageToken    = parser.peek();</span>
<span class="nc" id="L198">        int     startLineIndex  = packageToken.getLineIndex();</span>
        
<span class="nc" id="L200">        String fullyQualifiedPackage = &quot;&quot;;</span>
        
        while (true)
        {
<span class="nc" id="L204">            parser.nextToken();</span>

<span class="nc bnc" id="L206" title="All 2 branches missed.">            if (parser.atEOF())</span>
            {
<span class="nc" id="L208">                int qualifiedNameStartLineIndex = packageToken.getLineIndex();</span>
                
<span class="nc" id="L210">                Logger.err(parser.peek(-1), &quot;Expected \&quot;;\&quot; to end &quot; + </span>
                    &quot;package declaration on line &quot; + (packageToken.
<span class="nc" id="L212">                    getLineIndex() + 1));</span>

                //  synchronize parser
                
<span class="nc" id="L216">                parser.setToken(startTokenIndex);</span>
<span class="nc" id="L217">                fullyQualifiedPackage = &quot;&quot;;</span>
                
                while (true)
                {
<span class="nc" id="L221">                    parser.nextToken();</span>
                    
<span class="nc bnc" id="L223" title="All 2 branches missed.">                    if (parser.getCurTokLineIndex() != </span>
                        qualifiedNameStartLineIndex)
                    {
<span class="nc" id="L226">                        return new Statement.Package(fullyQualifiedPackage,</span>
                            startLineIndex);
                    }
                    
<span class="nc" id="L230">                    fullyQualifiedPackage += parser.peek().getTextContent();</span>
                }
            }
<span class="nc bnc" id="L233" title="All 2 branches missed.">            else if (parser.peekMatches(&quot;;&quot;))</span>
            {
<span class="nc" id="L235">                return new Statement.Package(fullyQualifiedPackage,</span>
                    startLineIndex);
            }

<span class="nc" id="L239">            fullyQualifiedPackage += parser.peek().getTextContent();</span>
        }
    }
    
    private Statement handleInvalidStartOfStatement()
    {
<span class="nc" id="L245">        Token next = parser.peek();</span>
<span class="nc" id="L246">        Logger.err(next, &quot;\&quot;&quot; + next.getTextContent() + &quot;\&quot; cannot be the &quot; +</span>
            &quot;start of a new statement&quot;);
        
<span class="nc" id="L249">        parser.gotoEndOfStatement();</span>
        
<span class="nc bnc" id="L251" title="All 2 branches missed.">        if (parser.atEOF())</span>
        {
            //this should never happen so dump ast and stack trace
<span class="nc" id="L254">            parser.dumpAstToStdout();</span>
            try
            { 
<span class="nc" id="L257">                throw new Exception(&quot;Fatal parse error: prematurely reached &quot; +</span>
                    &quot;end of file&quot;);
            }
<span class="nc" id="L260">            catch (Exception ex)</span>
            {
<span class="nc" id="L262">                ex.printStackTrace();</span>
            }
            
            //exit because otherwise our parser goes into an infinite loop
<span class="nc" id="L266">            System.exit(1);</span>
        }
        
        //try to synchronize parser
<span class="nc" id="L270">        return new Statement.VarDeclaration(Sign.UNSPECIFIED, </span>
            SimplifiedType.VOID, 0, 
                
            new Token(
                new TokenInfo(&quot;null&quot;, true),

<span class="nc" id="L276">                new TokenFileInfo(next.getFilepath(), next.getLineIndex())),</span>
                
<span class="nc" id="L278">            null, null, parser.getCurTokLineIndex());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>